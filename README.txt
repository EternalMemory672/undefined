    ___              __         ______          
   /   |  ____  ____/ /_  __   / ____/_  ______ 
  / /| | / __ \/ __  / / / /  / /_  / / / / __ \
 / ___ |/ / / / /_/ / /_/ /  / __/ / /_/ / / / /
/_/  |_/_/ /_/\__,_/\__, /  /_/    \__,_/_/ /_/ 
                   /____/     
**思路**
0. 整体流程：
    目录文件扫描分类 => SQL注入模块 => XSS攻击模块 => 文件上传模块 => 弱口令爆破模块 => 生成报告
1. 目录文件扫描分类
    1.1 主动扫描策略
        - 整理字典
            目录名字典、文件名字典、文件后缀字典（使用clean.py过滤无效字典项，去重，去异）
        - 渗透扫描
            - 从首页（可能是显式的http(s)://[IP/domain]/index{.ext}或者隐式的http(s)://[IP/domain]/由中间件指定默认首页）开始
            - 抽取页面中所有herf的值，进行简单过滤得到该页面指向的其他目录，递归地请求所有herf指向的地址直到没有新的href加入列表为止（预期得到html/htm/xhtml/js）
            - 检查所有即得html上的<form>标签，抽取action的值得到form的请求连接,抽取name的值获得请求参数，由此构建一个请求URL
            - 检查所有即得html上的<script>标签或独立js代码，尝试从window.location方法中获得js请求的url（至此预期整理得到所有可能存在漏洞的点）
            [!] 此方法存在大量难以解决问题：
                1. 各个网页设计不同，难以找到统一的匹配策略抓取所有存在漏洞的URL
                2. js代码构造复杂，用python难以复刻真实的浏览场景（js中的直接跳转，ajax请求，参数和URL分离）
                3. 若请求中包含token或cookie等其他身份验证机制则可能导致扫描失败
        - 碰撞扫描（类似dirbuster）
            1. 扫描网站根目录存在的路径，对结果进行二次扫描，不断迭代直到没有新路径产生或者达到最大深度
            2. 对所有扫描出的路径中的文件进行扫描得到文件列表
            3. 对所有扫描出的文件的参数进行试验，得到请求参数名（至此预期整理得到所有可能存在漏洞的点）
            [!] 此方法存在的问题：
                1. 时间空间开销极大，时间问题可以考虑使用pyhton多进程、cython等方法进行优化（中型字典约4分钟扫描一次、小型字典约1-2分钟）
                2. **请求过快过多可能导致IP被封禁导致扫描中断**
                3. 网站真实目录名千变万化，该方法可能无法检出
                4. 字典选择极其重要，被污染的字典不仅成本大且不能得到预期结果（进行字典净化）
    1.2 被动扫描策略
        - 打开本地代理服务器，将浏览器连接到代理服务器（python pproxy模块）
        - 在浏览器中访问目标网站并进行操作，包括但不限于登录、点击、上传文件、提交信息等操作
        - pproxy在后台记录用户访问，写入outfile.txt，访问结束后关闭pproxy结束记录
        - 主进程读取outfile.txt抽取请求头和参数，token、cookie、用户名、密码等用于身份认证的必要信息（至此预期整理得到所有可能存在漏洞的点）
        - 将结果分类传入之后的模块，进行漏洞测试
        [!] 此方法存在的问题：
            1. python的http代理比较小众需要学习和尝试
            2. 浏览行为将产生大量无效数据，需要设计合理的过滤筛选策略
            3. 浏览结束行为可能需要用户手动中断代理进程
            4. 有些代码程序等用户可能无法触及（被代理记录），但存在漏洞点
            4. 自动化程度较主动扫描策略稍低
    1.3 主被动结合扫描策略（可能的最优策略）
        - 被动扫描
        - 在临时字典中去除已经扫描到的路径和文件以节省成本
        - 由被动扫描确定的后端编程语言简化文件爆破（主动扫描中可能需要用户自行输入判断的网站后端的语言类型）
        - 将两者的列表整合去重，传给其他模块
        [!] 此方法存在的问题：
            - 实现困难，开发流程长

2. SQL注入模块
    1. 接收URL列表
    2. 打开SQLmap server（python多线程）
    3. 向SQLmap server发送请求，开始对URL的扫描（二次多线程）
    4. 等待SQLmap server完成扫描
    5. 收集各线程的扫描结果并进行整理
    6. 关闭SQLmap server并将扫描结果传入报告生成模块
    [*] 此模块除二次多线外已实现
    [!] 此方法存在的问题：
        - 二次多线程实现困难
3. XSS攻击模块

4. 文件上传模块

5. 弱口令模块

6. 报告生成模块
    1. 传入各模块产生的扫描结果
    2. 统一写入report.txt
    格式如下：